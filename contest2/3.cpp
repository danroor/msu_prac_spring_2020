/*

# 3

В пространстве имен numbers реализуйте функцию eval с прототипом:

complex eval(const std::vector<std::string> &args, const complex &z);
Функции подается на вход польская инверсная запись выражения над комплексными числами с одной переменной и
значение переменной. В качестве результата функция возвращает вычисленное значение.

Каждый элемент польской записи находится в отдельном элементе вектора.

Возможные ошибки при вычислении игнорируйте.

Вы должны сдать только функцию eval.

В польской записи допускаются следующие элементы:

Запись комплексного числа в виде (RE,IM) (см. предыдущие задачи).
Обозначение переменной "z" (строчная латинская буква).
Знаки бинарных операций +, -, *, /.
Знак унарной операции !, которая заносит в стек элемент, находящийся на верхушке стека.
Знак унарной операции ;, которая удаляет элемент с верхушки стека.
Знак унарной операции ~, которая вычисляет комплексно-сопряженное число.
Знак унарной операции #, которая меняет знак у числа.
Обратите внимание, что польская запись z1 z2 - обозначает (z1 - z2), а не (z2 - z1)!

Каждая строка в массиве строк содержит ровно один элемент польской записи. Пробельные символы отсутствуют.

Реализуйте отображение из операций в действия с помощью отображения (std::map) анонимных функций.


*/

#include <vector>
#include <functional>
#include <map>

namespace numbers {
    complex eval(const std::vector<std::string> &args, const complex &z) {
        complex_stack st;

        std::map<std::string, std::function<void()> > ops = {

            {"+", [&st]() {
                complex x = +st;
                st = ~st;
                complex y = +st;
                st = (~st) << y + x;
            } },

            {"-", [&st]() {
                complex x = +st;
                st = ~st;
                complex y = +st;
                st = (~st) << y - x;
            } },

            {"*", [&st]() {
                complex x = +st;
                st = ~st;
                complex y = +st;
                st = (~st) << y * x;
            } },
   
            {"/", [&st]() {
                complex x = +st;
                st = ~st;
                complex y = +st;
                st = (~st) << y / x;
            } },

            {"!", [&st]() {
                complex x = +st;
                st = st << x;
            } },

            {";", [&st]() {
                st = ~st;
            } },
 
            {"~", [&st]() {
                complex x = +st;
                st = ~st;
                st = st << ~x;
            } },
  
            {"#", [&st]() {
                complex x = +st;
                st = ~st;
                st = st << -x;
            } },
        };

        for (auto v : args) {
            switch(v[0]) {
            case '(':
                st = st << complex(v);
                break;
            case 'z':
                st = st << z;
                break;
            default:
                ops.at(v)();
            }
        }

        return +st;
    }
}
